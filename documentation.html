<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>ZMap · Documentation</title>
		<meta name="description" context="some description should go here"/>
		
		<link href="css/bootstrap.min.css" rel="stylesheet"/>
		<link href="css/bootstrap-responsive.min.css" rel="stylesheet"/>
		<link href="css/local.css" rel="stylesheet"/>
	</head>
<script type="text/javascript">
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '51f73359108d7b36f5000203');
    t.src = '//secure.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>
	<body>
		<script type="text/JavaScript" src="js/jquery.min.js"></script> 
		<script type="text/JavaScript" src="js/bootstrap.min.js"></script> 
		<div class="navbar navbar-static-top navbar-inverse">
		  <div class="navbar-inner">
		    <a class="brand" href="index.html">ZMap · The Internet Scanner</a>
		    <ul class="nav pull-right">
					<li><a href="paper.html">Research Paper</a></li>
		      <li class="active"><a href="documentation.html">Documentation</a></li>
		        <li><a href="projects.html">Projects</a></li>
					<li><a href="download.html">Download</a></li>
        <li><a href="https://scans.io">Data Repository</a></li>
		    </ul>
		  </div>
		</div>
	<div class="content">
			<div class="container">
				<div class="row-fluid"> 
					<div class="span10 white-panel offset1 title">
						<div class="content">
						  <h3>ZMap Documentation</h3>
						  <div class="container">
						    <div class="row-fluid"> 
						      <div class="span4 offset1">
						        <p class="front"><b>1. <a href="#gettingstarted">Getting Started with ZMap</a></b></p>
						        <p class="front"><b>2. <a href="#bestpractices">Scanning Best Practices</a></b></p>
                                <p class="front"><b>3. <a href="#args">Command Line Arguments</a></b></p>
                                <p class="section"><b>4. <a href="#additional">Additional Information</a></b></p>
                                <ol class="subsection">
                                  <li><a href="#tcp_synscan">TCP SYN Probe Module</a></li>
                                  <li><a href="#icmp_echoscan">ICMP Echo Probe Module</a></li>
                                  <li><a href="#udp">UDP Probe Module</a></li>
                                  <li><a href="#config">Configuration Files</a></li>
                                  <li><a href="#verbosity">Verbosity</a></li>
                                  <li><a href="#output">Results Output</a></li>
                                  <li><a href="#blacklisting">Blacklisting</a></li>
                                  <li><a href="#ratelimiting">Rate Limiting and Sampling</a></li>
                                  <li><a href="#multiple">Sending Multiple Probes</a></li>
                                </ol>
						      </div>
						      <div class="span5">
      							<p class="section"><b>5. <a href="#applications">Extending ZMap</a></b></p>
      							<ol class="subsection">
      							  <li><a href="#applications">Sample Applications</a></li>
      							  <li><a href="#extending">Writing Probe and Output Modules</a></li>
      							  </ol>
			      </div>
			    </div>
			  </div>
			</div>
			</div>
			<div class="row-fluid"> 
					<div class="span10 white-panel offset1 nontitle">
						<div class="content">
                         <a name="gettingstarted"></a>
						  <h3>Getting Started with ZMap</h3>

                          <p class="front">
ZMap is designed to perform comprehensive scans of the IPv4 address space or large portions of it. While ZMap is a powerful tool for researchers, please keep in mind that by running ZMap, you are potentially scanning the <b>ENTIRE</b> IPv4 address space at over 1.4 million packets per second. Before performing even small scans, we encourage users to contact their local network administrators and consult our list of <a href="#bestpractices">scanning best practices</a>.</p>

                <p class="front">By default, ZMap will perform a TCP SYN scan on the specified
port at the maximum rate possible. A more conservative configuration that will scan 10,000 random
addresses on port 80 at a maximum 10 Mbps can be run as follows:</p>

                <div class="indent"><pre><b>$ zmap --bandwidth=10M --target-port=80 --max-targets=10000 --output-file=results.csv </b></pre></div>
                <p class="front">Or more concisely specified as:</p>
                <div class="indent"><pre><b>$ zmap -B 10M -p 80 -n 10000 -o results.csv</b></pre></div>
				
                <p class="front">ZMap can also be used to scan specific subnets or CIDR blocks. For example, to scan only 10.0.0.0/8 and 192.168.0.0/16 on port 80, run:</p>

                <div class="indent"><pre>zmap -p 80 -o results.csv 10.0.0.0/8 192.168.0.0/16</pre></div>
				
                <p class="front">If the scan started successfully, ZMap will output status updates every one second similar to the following:</p>
<div class="indent"><pre>
0% (1h51m left); send: 28777 562 Kp/s (560 Kp/s avg); recv: 1192 248 p/s (231 p/s avg); hits: 0.04%
0% (1h51m left); send: 34320 554 Kp/s (559 Kp/s avg); recv: 1442 249 p/s (234 p/s avg); hits: 0.04%
0% (1h50m left); send: 39676 535 Kp/s (555 Kp/s avg); recv: 1663 220 p/s (232 p/s avg); hits: 0.04%
0% (1h50m left); send: 45372 570 Kp/s (557 Kp/s avg); recv: 1890 226 p/s (232 p/s avg); hits: 0.04%</pre></div>

<p class="front">These updates provide information about the current state of the scan and are of the following form: %-complete (est time remaining); packets-sent curr-send-rate (avg-send-rate); recv: packets-recv recv-rate (avg-recv-rate); hits: hit-rate </p>

                <p class="front">If you do not know the scan rate that your
                network can support, you may want to experiment with different
                scan rates or bandwidth limits to find the fastest rate that
                your network can support before you see decreased results.</p>

                <p class="front">By default, ZMap will output the list of
                distinct IP addresses that responded successfully (e.g. with a SYN ACK packet) similar to the following. There are several
                additional formats (e.g. JSON and Redis) for <a href="#output">outputting
                results</a> as well as options for producing <a
                href="#verbosity">programmatically parsable scan
                statistics</a>. As wells, additional <a href="#outputfields">output fields</a> can be specified and the results can be filtered using an <a href="#outputfilter">output filter</a>.</p>

                <div class="indent"><pre>115.237.116.119
23.9.117.80
207.118.204.141
217.120.143.111
50.195.22.82
</pre></div>


<p class="front">We strongly encourage you to use a <a href="#blacklisting">blacklist file</a>, to exclude both reserved/unallocated IP space (e.g. multicast, RFC1918), as well as networks that request to be excluded from your scans. By default, ZMap will utilize a simple blacklist file containing reserved and unallocated addresses located at <code>/etc/zmap/blacklist.conf</code>. If you find yourself specifying certain settings, such as your maximum bandwidth or <a href="#blacklisting">blacklist file</a> every time you run ZMap, you can specify these in <code>/etc/zmap/zmap.conf</code> or use a custom <a href="#config">configuration file</a>.</p>

     <p class="front">If you are attempting to troubleshoot scan related issues, there are several options to help debug. First, it is possible to perform a <a href="#dryrun">dry run scan</a> in order to see the packets that would be sent over the network by adding the <code>--dryrun</code> flag. As well, it is possible to change the <a href="#verbosity">logging verbosity</a> by setting the <code>--verbosity=n</code> flag.
    </p>   

<p class="front">
</p>
       <p class="front">
     
	</div>
	</div>
	<div class="row-fluid"> 
	<div class="span10 white-panel offset1 nontitle">
	<div class="hometitle">
	  <a name="bestpractices"></a>
	  <h3>Scanning Best Practices</h3>
              <p class="front">
                We offer these suggestions for researchers conducting Internet-wide scans as guidelines for good Internet citizenship.</p>
                <ol class="recommendations">
                  <li class="">Coordinate closely with local network administrators to
                  reduce risks and handle inquiries</li>
                  <li class="">Verify that scans will not overwhelm the local network or upstream provider</li>
                  <li class="">Signal the benign nature of the scans in web pages
                  and DNS entries of the source addresses</li>
                  <li class="">Clearly explain the purpose and scope of the scans
                  in all communications</li>
                  <li class="">Provide a simple means of opting out and honor
                  requests promptly</li>
                  <li class="">Conduct scans no larger or more frequent than is
                  necessary for research objectives</li>
                  <li class="">Spread scan traffic over time or source addresses
                  when feasible</li>
                </ol>
                <p class="front">It should go without saying that scan
                researchers should refrain from exploiting vulnerabilities or accessing protected resources, and should comply
                with any special legal requirements in their jurisdictions.</p>
					</div>
				</div>


<!-- Command Line Arguments -->
<div class="row-fluid">
  <div class="span10 white-panel offset1 nontitle">
    <div class="content">
    <a name="args"></a>
    <h3>Command Line Arguments</h3>


        <h4>Common Options</h4>
	<p>These options are the most common options when performing a simple scan. We note that some options are dependent on the <a href="#probemodule">probe module</a> or <a href="#outputmodule">output module</a> used (e.g. target port is not used when performing an ICMP Echo Scan). </p>

        <dl class="dl-horizontal params">
          <dt>-p, --target-port=port</dt>       <dd>TCP port number to scan (e.g. <b>443</b>)</dd>
          <dt>-o, --output-file=name</dt>       <dd>Write results to this file. Use - for stdout</dd>
          <dt>-b, --blacklist-file=path</dt>    <dd>File of subnets to exclude, in CIDR notation (e.g. 192.168.0.0/16), 
                                                    one-per line. It is recommended you use this to exclude RFC 1918 addresses,
                                                    multicast, IANA reserved space, and other IANA special-purpose addresses. 
                                                    An example blacklist file is provided in <b>conf/blacklist.example</b>
                                                    for this purpose.</dd>
        </dl>
        <a name="scanoptions"></a>
        <h4>Scan Options</h4>

        <dl class="dl-horizontal params">
          <dt>-n, --max-targets=n</dt>          <dd>Cap the number of targets to probe. This can either be a number (e.g. <code>-n 1000</code>)
                                                or a percentage (e.g. <code>-n 0.1%</code>) of the scannable address space (after excluding blacklist)</dd>
          <dt>-N, --max-results=n</dt>          <dd>Exit after receiving this many results</dd>
          <dt>-t, --max-runtime=secs</dt>       <dd>Cap the length of time for sending packets</dd>
          <dt>-r, --rate=pps</dt>               <dd>Set the send rate in packets/sec</dd>
          <dt>-B, --bandwidth=bps</dt>          <dd>Set the send rate in bits/second (supports suffixes G, M, and K (e.g. <code>-B 10M</code> for 10 mbps).
                                                This overrides the <code>--rate</code> flag.</dd>

          <dt>-c, --cooldown-time=secs</dt>     <dd>How long to continue receiving after sending has completed (default=8)<dd>
          <dt>-e, --seed=n</dt>                 <dd>Seed used to select address permutation. Use this if you want to
                                                scan addresses in the same order for multiple ZMap runs.</dd>
          <dt>--shards=n</dt>                   <dd>Split the scan up into N shards/partitions among different instances
                                                    of zmap (default=1). When sharding, <code>--seed</code> is required</dd>
          <dt>--shard=n</dt>                    <dd>Set which shard to scan (default=0). Shards are indexed in the range [0, N),
                                                    where N is the total number of shards. When sharding <code>--seed</code> is required.</dd>
          <dt>-T, --sender-threads=n</dt>       <dd>Threads used to send packets (default=1)</dd>
          <dt>-P, --probes=n</dt>               <dd>Number of probes to send to each IP (default=1)</dd>
          <dt>-d, --dryrun</dt>                 <dd>Print out each packet to stdout instead of sending it (useful for debugging)</dd>
        </dl>

        <h4>Network Options</h4>

        <dl class="dl-horizontal params">
          <dt>-s, --source-port=port|range</dt> <dd>Source port(s) to send packets from</dd>
          <dt>-S, --source-ip=ip|range</dt>     <dd>Source address(es) to send packets from. Either single IP or range (e.g. 10.0.0.1-10.0.0.9)</dd>
          <dt>-G, --gateway-mac=addr</dt>       <dd>Gateway MAC address to send packets to (in case auto-detection does not work)</dd>
          <dt>-i, --interface=name</dt>         <dd>Network interface to use</dd>
        </dl>

        <h4>Probe Options</h4>

        <p>ZMap allows users to specify and write their own <a href="#probemodule">probe modules</a> for use with ZMap. Probe modules are responsible for generating probe packets to send, and processing responses from hosts.</p>

        <dl class="dl-horizontal params">
          <dt>--list-probe-modules</dt>         <dd>List available probe modules (e.g. tcp_synscan)</dd>
          <dt>-M, --probe-module=name</dt>      <dd>Select <a href="#probemodule">probe module</a> (default=tcp_synscan)</dd>
          <dt>--probe-args=args</dt>            <dd>Arguments to pass to probe module</dd>
          <dt>--list-output-fields</dt>         <dd>List the fields the selected probe module can send to the output module</dd>
        </dl>

        <h4>Output Options</h4>

        <p>ZMap allows users to specify and write their own <a href="#outputmodule">output modules</a> for use with ZMap. Output modules are responsible for processing the fieldsets returned by the probe module, and outputing them to the user. Users can specify output fields, and write filters over the output fields.</p>

        <dl class="dl-horizontal params">
          <dt>--list-output-modules</dt>        <dd>List available output modules (e.g. tcp_synscan)</dd>
          <dt>-O, --output-module=name</dt>     <dd>Select <a href="#outputmodule">output module</a> (default=csv)</dd>
          <dt>--output-args=args</dt>           <dd>Arguments to pass to output module</dd>
          <dt>-f, --output-fields=fields</dt>   <dd>Comma-separated list of fields to output</dd>
          <dt>--output-filter</dt>              <dd>Specify an <a href="#outputfilter">output filter</a> over the fields defined by the <a href="#probemodule">probe module</a></dd>
        </dl> 

        <h4>Additional Options</h4>
        <dl class="dl-horizontal params">
          <dt>-C, --config=filename</dt>        <dd>Read a <a href="#config">configuration file</a>, which can specify any other options.</dd>
          <dt>-q, --quiet</dt>                  <dd>Do not print status updates once per second</dd>
          <dt>-g, --summary</dt>                <dd>Print configuration and summary of results at the end of the scan</dt>
          <dt>-v, --verbosity=n</dt>            <dd>Level of log detail (0-5, default=3)</dd>
          <dt>-h, --help</dt>                   <dd>Print help and exit</dd>
          <dt>-V, --version</dt>                <dd>Print version and exit</dd>
        </dl>
    </div>
  </div>
</div>

				<div class="row-fluid"> 
					<div class="span10 white-panel offset1 nontitle">
						<div class="content">
                        <a name="additional"></a>
						  <h3>Additional Information</h3>

						

<!--
						<p>ZMap uses different arguments depending on the <a href="#probemodule">probe module</a> used.
						The default probe module is the TCP SYN scan (<code>-M tcp_synscan</code>).

	      <p> ZMap supports sending packets from multiple source IP
addresses and in the case of TCP SYN scans, from multiple ports.  Because ZMap
utilizes a raw socket to send network packets and <b>libpcap</b> to collect
responses, ZMap must be run as root or with <b>cap_net_raw</b> (recommended).
In the case that you want packets sent through a non-default interface, this
can be be set by providing the <strong>interface</strong> argument.</p> <p>
Basic arguments:</p>
							
							<dl class="dl-horizontal params">
								<dt>-S, - -source-ip=ip|range</dt><dd>Source address(es) for scan packets (e.g. <b>1.1.1.3-1.1.1.8</b>)</dd>
							  	<dt>-G, - -gateway-mac=addr</dt><dd>Specify gateway MAC address (e.g. <b>b4:23:f9:28:fa:2d</b>)</dd>
								<dt>-I, - -interface=name</dt><dd>Specify network interface to use (e.g. <b>eth1</b>)</dd>
							</dl>
							
<p><span class="label label-info">Heads Up!</span> One of the reasons that ZMap supports sending
packets from multiple addresses and source ports is because this allows the
scanner to embed small amounts of packet checksum data in these fields. This
functionality helps the scanner separate legitimate responses from extraneous
responses that may be received during scan runtime.</p>	
-->
							<a name="tcp_synscan"></a>									
							<h4>TCP SYN Scans</h4>
							<p>When performing a TCP SYN scan, ZMap requires a single target port and supports specifying a range of source ports from which the scan will originate.</p>
							<dl class="dl-horizontal params">
								<dt>-p, --target-port=port</dt><dd>TCP port number to scan (e.g. <b>443</b>)</dd>
								<dt>-s, --source-port=port|range</dt><dd>Source port(s) for scan packets (e.g. <strong>40000-50000</strong>)</dd>
							</dl>

                            <p><span class="label
label-warning">Warning!</span> ZMap relies on the Linux kernel to respond to
SYN/ACK packets with RST packets in order to close connections opened by the
scanner. This occurs because ZMap sends packets at the Ethernet layer in order
to reduce overhead otherwise incurred in the kernel from tracking open TCP
connections and performing route lookups. As such, if you have a firewall rule
that tracks established connections such as a netfilter rule similar to
<code>-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code>, this will
block SYN/ACK packets from reaching the kernel. This will not prevent ZMap from
recording responses, but it will prevent RST packets from being sent back,
ultimately using up a connection on the scanned host until your connection
times out. We strongly recommend that you select a set of unused ports on your
scanning host which can be allowed access in your firewall and specifying this
port range when executing ZMap, with the <code>-s</code> flag (e.g. <code>-s '50000-60000'</code>).

<a name="icmp_echoscan"></a>		
<h4>ICMP Echo Request Scans</h4>
	<p>While ZMap performs TCP SYN scans by default, it also supports ICMP echo request scans in which an ICMP echo request packet is sent to each host and the type of ICMP response received in reply is denoted. An ICMP scan can be performed by selecting the <strong>icmp_echoscan</strong> scan module similar to the following:</p>
							<div class="indent"><pre><b> $ zmap --probe-module=icmp_echoscan</b></pre></div>
							<br/>

<a name="udp"></a>
<h4>UDP Datagram Scans</h4>
	<p>ZMap additionally supports UDP probes, where it will send out an arbitrary UDP datagram to each host, and receive either UDP or ICMP Unreachable responses. ZMap supports four different methods of setting the UDP payload through the --probe-args command-line option. These are 'text' for ASCII-printable payloads, 'hex' for hexadecimal payloads set on the command-line, 'file' for payloads contained in an external file, and 'template' for payloads that require dynamic field generation. In order to obtain the UDP response, make sure that you specify 'data' as one of the fields to report with the -f option.
  </p><br/>

  <p>The example below will send the two bytes 'ST', a PCAnwywhere 'status' request, to UDP port 5632.</p><br/>

		<div class="indent"><pre><b> $ zmap -M udp -p 5632 --probe-args=text:ST -N 100 -f saddr,data -o -</b></pre></div>

  <p>The example below will send the byte '0x02', a SQL Server 'client broadcast' request, to UDP port 1434.</p><br/>

    <div class="indent"><pre><b> $ zmap -M udp -p 1434 --probe-args=hex:02 -N 100 -f saddr,data -o -</b></pre></div>

  <p>The example below will send a NetBIOS status request to UDP port 137. This uses a payload file that is included with the ZMap distribution.</p><br/>

    <div class="indent"><pre><b> $ zmap -M udp -p 1434 --probe-args=file:netbios_137.pkt -N 100 -f saddr,data -o -</b></pre></div>

  <p>The example below will send a SIP 'OPTIONS' request to UDP port 5060. This uses a template file that is included with the ZMap distribution.</p><br/>
    <div class="indent"><pre><b> $ zmap -M udp -p 1434 --probe-args=template:sip_options.tpl -N 100 -f saddr,data -o -</b></pre></div>

  <p>UDP payload templates are still experimental. You may encounter crashes when more using more than one send thread (-T) and there is a significant decrease in performance compared to static payloads. A template is simply a payload file that contains one or more field specifiers enclosed in a ${} sequence. Some protocols, notably SIP, require the payload to reflect the source and destination of the packet. Other protocols, such as portmapper and DNS, contain fields that should be randomized per request or risk being dropped by multi-homed systems scanned by ZMap.</p><br/>

  <p>The payload template below will send a SIP OPTIONS request to every destination:</p>
    <div class="indent">
<pre><b>OPTIONS sip:${RAND_ALPHA=8}@${DADDR} SIP/2.0
Via: SIP/2.0/UDP ${SADDR}:${SPORT};branch=${RAND_ALPHA=6}.${RAND_DIGIT=10};rport;alias
From: sip:${RAND_ALPHA=8}@${SADDR}:${SPORT};tag=${RAND_DIGIT=8}
To: sip:${RAND_ALPHA=8}@${DADDR}
Call-ID: ${RAND_DIGIT=10}@${SADDR}
CSeq: 1 OPTIONS
Contact: sip:${RAND_ALPHA=8}@${SADDR}:${SPORT}
Content-Length: 0
Max-Forwards: 20
User-Agent: ${RAND_ALPHA=8}
Accept: text/plain
</b></pre></div>

<p>In the example above, note that line endings are \r\n and the end of this request must contain \r\n\r\n for most SIP implementations to correcly process it. A working example is included in the examples/udp-payloads directory of the ZMap source tree (sip_options.tpl).</p>

<p>The following template fields are currently implemented:</p>
<ul>
<li><b>SADDR</b>: Source IP address in dotted-quad format</li>
<li><b>SADDR_N</b>: Source IP address in network byte order</li>
<li><b>DADDR</b>: Destination IP address in dotted-quad format</li>
<li><b>DADDR_N</b>: Destination IP address in network byte order</li>
<li><b>SPORT</b>: Source port in ascii format</li>
<li><b>SPORT_N</b>: Source port in network byte order</li>
<li><b>DPORT</b>: Destination port in ascii format</li>
<li><b>DPORT_N</b>: Destination port in network byte order</li>
<li><b>RAND_BYTE</b>: Random bytes (0-255), length specified with =(length) parameter</li>
<li><b>RAND_DIGIT</b>: Random digits from 0-9, length specified with =(length) parameter</li>
<li><b>RAND_ALPHA</b>: Random mixed-case letters from A-Z, length specified with =(length) parameter</li>
<li><b>RAND_ALPHANUM</b>: Random mixed-case letters from A-Z and digits from 0-9, length specified with =(length) parameter</li>
</ul></br>


                            <a name="config"></a>
							<h3>Configuration Files</h3>

                            <p>ZMap supports configuration files instead of
requiring all options to be specified on the command-line. A configuration can
be created by specifying one long-name option and the value per line such
as:</p>

							<div class="indent"><pre>
interface "eth1"
source-ip 1.1.1.4-1.1.1.8
gateway-mac b4:23:f9:28:fa:2d # upstream gateway
cooldown-time 300 # seconds
blacklist-file /etc/zmap/blacklist.conf
output-file ~/zmap-output
quiet
summary
</pre></div>

<p>ZMap can then be run with a configuration file and specifying any additional necessary parameters:</p>
<div class="indent"><pre><b> $ zmap --config=~/.zmap.conf --target-port=443</b></pre></div>

							<br/>

							<a name="verbosity"></a>
							<h3>Verbosity</h3>
							<p>There are several types of on-screen output that ZMap produces. By default, ZMap will print out basic progress information similar to the following every 1 second. This can be disabled by setting the <code>--quiet</code> flag.</p>
							<div class="indent"><pre>0:01 12%; send: 10000 done (15.1 Kp/s avg); recv: 144 143 p/s (141 p/s avg); hits: 1.44%</pre></div>

<br/>
<p>ZMap also prints out informational messages during scanner configuration such as the following, which can be controlled with the <code>--verbosity</code> argument.</p>
<div class="indent"><pre>
Aug 11 16:16:12.813 [INFO] zmap: started
Aug 11 16:16:12.817 [DEBUG] zmap: no interface provided. will use eth0
Aug 11 16:17:03.971 [DEBUG] cyclic: primitive root: 3489180582
Aug 11 16:17:03.971 [DEBUG] cyclic: starting point: 46588
Aug 11 16:17:03.975 [DEBUG] blacklist: 3717595507 addresses allowed to be scanned
Aug 11 16:17:03.975 [DEBUG] send: will send from 1 address on 28233 source ports
Aug 11 16:17:03.975 [DEBUG] send: using bandwidth 10000000 bits/s, rate set to 14880 pkt/s
Aug 11 16:17:03.985 [DEBUG] recv: thread started
</pre></div>
<br/>
<p>ZMap also supports printing out a grep-able summary at the end of the scan, similar to below, which can be invoked with the <code>--summary</code> flag.</p>
<div class="indent"><pre>
cnf	target-port				443
cnf	source-port-range-begin			32768
cnf	source-port-range-end			61000
cnf	source-addr-range-begin			1.1.1.4
cnf	source-addr-range-end			1.1.1.8
cnf	maximum-packets				4294967295
cnf	maximum-runtime				0
cnf	permutation-seed			0
cnf	cooldown-period				300
cnf	send-interface				eth1
cnf	rate					45000
env	nprocessors				16
exc	send-start-time				Fri Jan 18 01:47:35 2013
exc	send-end-time				Sat Jan 19 00:47:07 2013
exc	recv-start-time				Fri Jan 18 01:47:35 2013
exc	recv-end-time				Sat Jan 19 00:52:07 2013
exc	sent					3722335150
exc	blacklisted				572632145
exc	first-scanned				1318129262
exc	hit-rate				0.874102
exc	synack-received-unique			32537000
exc	synack-received-total			36689941
exc	synack-cooldown-received-unique		193
exc	synack-cooldown-received-total		1543
exc	rst-received-unique			141901021
exc	rst-received-total			166779002
adv	source-port-secret			37952
adv	permutation-gen				4215763218
</pre></div>
<br/>


							<a name="output"></a> 
							<h3>Results Output</h3>


              <p>ZMap can produce results in several formats through the use
of <b>output modules</b>. By default, ZMap only supports <b>csv</b> output,
however support for <b>redis</b> and <b>json</b> can be compiled in. The
results sent to these output modules may be filtered using an <strong>output
filter</strong>. The fields the output module writes are specified by the
user. By default, ZMap will return results in csv format and if no output file
is specified, ZMap will not produce specific results. It is also possible to
write your own output module; see <a href="#extending">Writing Output
Modules</a> for information.</p>

                <dl class="dl-horizontal params">
                  <dt>-o, --output-file=p</dt><dd>File to write output to</dd>
                  <dt>-O, --output-module=p</dt><dd>Invoke a custom output module</dd>
                  <dt>-f, --output-fields=p</dt><dd>Comma-separated list of fields to output</dd>
                  <dt>--output-filter=filter</dt><dd>Specify an output filter over fields for a given probe</dd>
                  <dt>--list-output-modules</dt><dd>Lists available output modules</dd>
                  <dt>--list-output-fields</dt><dd>List available output fields for a given probe</dd>
                </dl><br/>

                <a name="outputfields"></a>
                <h4>Output Fields</h4>
                <p>ZMap has a variety of fields it can output beyond IP address. These fields can be viewed for a given probe module by running with the <code>--list-output-fields</code> flag.</p>

<div class="indent"><pre><code>$ zmap --probe-module="tcp_synscan" --list-output-fields
saddr           string: source IP address of response
saddr-raw          int: network order integer form of source IP address
daddr           string: destination IP address of response
daddr-raw          int: network order integer form of destination IP address
ipid               int: IP identification number of response
ttl                int: time-to-live of response packet
sport              int: TCP source port
dport              int: TCP destination port
seqnum             int: TCP sequence number
acknum             int: TCP acknowledgement number
window             int: TCP window
classification  string: packet classification
success            int: is response considered success
repeat             int: is response a repeat response from host
cooldown           int: Was response received during the cooldown period
timestamp-str   string: timestamp of when response arrived in ISO8601 format.
timestamp-ts       int: timestamp of when response arrived in seconds since Epoch
timestamp-us       int: microsecond part of timestamp (e.g. microseconds since 'timestamp-ts')</code></pre></div>

                <p>To select which fields to output, any combination of the output fields can be specified as a comma-separated list using the <code>--output-fields=fields</code> or <code>-f</code> flags. Example:</p>

<div class="indent"><pre>
$ zmap -p 80 -f "response,saddr,daddr,sport,seq,ack,in_cooldown,is_repeat,timestamp" -o output.csv
</pre></div>                

                <a name="outputfilter"></a>
                <h4>Filtering Output</h4>

                <p>Results generated by a probe module can be filtered before being passed to the output module. Filters are defined over the output fields of a probe module. Filters are written in a simple filtering language, similar to SQL, and are passed to ZMap using the <strong>--output-filter</strong> option. Output filters are commonly used to filter out duplicate results, or to only pass only sucessful responses to the output module.</p>

                <p>Filter expressions are of the form <code>&lt;fieldname&gt; &lt;operation&gt; &lt;value&gt;</code>. The type of <code>&lt;value&gt;</code> must be either a string or unsigned integer literal, and match the type of <code>&lt;fieldname&gt;</code>. The valid operations for integer comparisons are <code>= !=, &lt;, &gt;, &lt;=, &gt;=</code>. The operations for string comparisons are <code>=, !=</code>. The <code>--list-output-fields</code> flag will print what fields and types are available for the selected probe module, and then exit.</p>

                <p>Compound filter expressions may be constructed by combining filter expressions using parenthesis to specify order of operations, the <code>&amp;&amp;</code> (logical AND) and <code>||</code> (logical OR) operators.</p>

                <h5>Examples</h5>

                <p>Write a filter for only successful, non-duplicate responses</p>
<pre><code>--output-filter="success = 1 &amp;&amp; repeat = 0"</code></pre>

                <p>Filter for packets that have classification RST and a TTL greater than 10, or for packets with classification SYNACK</p>

<pre><code>--output-filter="(classification = rst &amp;&amp; ttl > 10) || classification = synack"</code></pre>

                <br />

								<h4>CSV</h4>
								<p>The csv module will produce a comma-separated value file of the output fields requested. For example, the following command produces the following CSV in a file called <code>output.csv</code>.</p>
<div class="indent"><pre>
$ zmap -p 80 -f "response,saddr,daddr,sport,seq,ack,in_cooldown,is_repeat,timestamp" -o output.csv
</pre></div>
<div class="indent"><pre>
response, saddr, daddr, sport, dport, seq, ack, in_cooldown, is_repeat, timestamp
synack, 159.174.153.144, 10.0.0.9, 80, 40555, 3050964427, 3515084203, 0, 0,2013-08-15 18:55:47.681
rst, 141.209.175.1, 10.0.0.9, 80, 40136, 0, 3272553764, 0, 0,2013-08-15 18:55:47.683
rst, 72.36.213.231, 10.0.0.9, 80, 56642, 0, 2037447916, 0, 0,2013-08-15 18:55:47.691
rst, 148.8.49.150, 10.0.0.9, 80, 41672, 0, 1135824975, 0, 0,2013-08-15 18:55:47.692
rst, 50.165.166.206, 10.0.0.9, 80, 38858, 0, 535206863, 0, 0,2013-08-15 18:55:47.694
rst, 65.55.203.135, 10.0.0.9, 80, 50008, 0, 4071709905, 0, 0,2013-08-15 18:55:47.700
synack, 50.57.166.186, 10.0.0.9, 80, 60650, 2813653162, 993314545, 0, 0,2013-08-15 18:55:47.704
synack, 152.75.208.114, 10.0.0.9, 80, 52498, 460383682, 4040786862, 0, 0,2013-08-15 18:55:47.707
synack, 23.72.138.74, 10.0.0.9, 80, 33480, 810393698, 486476355, 0, 0,2013-08-15 18:55:47.710
</pre></div><br/>

				<h4>Redis</h4>
                <p>The redis output module allows addresses to be added to a
                Redis queue instead of being saved to file which ultimately
                allows ZMap to be incorporated with post processing tools.</p>
  
                <p> <span class="label label-info">Heads Up!</span> ZMap does not build with
                Redis support by default. If you are building ZMap from source, you can
                build with Redis support by running CMake with
                <code>-DWITH_REDIS=ON</code>.</p>

                <br />

                <h4>JSON</h4>
                <p>The JSON output module operates similar to the CSV module,
                except it writes output in JSON format to a file. The JSON
                file can then be easily imported into other programs that can
                read JSON.</p>

                <p> <span class="label label-info">Heads Up!</span> ZMap does
                not build with JSON support by default. If you are building
                ZMap from source, you can build with JSON support by running
                CMake with <code>-DWITH_JSON=ON</code>.</p>

								<br/>


<!--
							<a name="address"></a> 
							<h3>Scan Order and Address Selection</h3>
							
							<p>IP addresses are scanned in a random permutation that is generated at the beginning of each scan. If you want to scan addresses in the same order over multiple scans or to scan the same subset of the IPv4 address space (see <a href="#sampling">sampling</a>), you can specify the permutation by specifying the seed option. It is not possible to specify the exact order in which addresses are scanned.</p>

							<dl class="dl-horizontal params">
							  <dt>-s, --seed=n</dt><dd>Set seed for selecting address permutation</dd>
							</dl>
							<br/>
-->


							<a name="blacklisting"></a> 
							<h3>Blacklisting and Whitelisting</h3>
							<p>ZMap supports both blacklisting and whitelisting network prefixes. If ZMap is not provided with blacklist or whitelist parameters, ZMap will scan all IPv4 addresses (including local, reserved, and multicast addresses). If a blacklist file is specified, network prefixes in the blacklisted segments will not be scanned; if a whitelist file is provided, only network prefixes in the whitelist file will be scanned. A whitelist and blacklist file can be used in coordination; the blacklist has priority over the whitelist (e.g. if you have whitelisted 10.0.0.0/8 and blacklisted 10.1.0.0/16, then 10.1.0.0/16 will not be scanned). Whitelist and blacklist files can be specified on the command-line as follows:</p>
<dl class="dl-horizontal params">
  <dt>-b, --blacklist-file=path</dt><dd>File of subnets to blacklist in CIDR notation, e.g. 192.168.0.0/16</dd>
	<dt>-w, --whitelist-file=path</dt><dd>File of subnets to limit scan to in CIDR notation, e.g. 192.168.0.0/16</dd>
</dl>
	
<p>Blacklist files should be formatted with a single network prefix in <a href="http://en.wikipedia.org/wiki/CIDR_notation">CIDR notation</a> per line. Comments are allowed using the <code>#</code> character. Example:</p>
						
<div class="indent"><pre>
# From IANA IPv4 Special-Purpose Address Registry
# http://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml
# Updated 2013-05-22

0.0.0.0/8           # RFC1122: "This host on this network"
10.0.0.0/8          # RFC1918: Private-Use
100.64.0.0/10       # RFC6598: Shared Address Space
127.0.0.0/8         # RFC1122: Loopback
169.254.0.0/16      # RFC3927: Link Local
172.16.0.0/12       # RFC1918: Private-Use
192.0.0.0/24        # RFC6890: IETF Protocol Assignments
192.0.2.0/24        # RFC5737: Documentation (TEST-NET-1)
192.88.99.0/24      # RFC3068: 6to4 Relay Anycast
192.168.0.0/16      # RFC1918: Private-Use
192.18.0.0/15       # RFC2544: Benchmarking
198.51.100.0/24     # RFC5737: Documentation (TEST-NET-2)
203.0.113.0/24      # RFC5737: Documentation (TEST-NET-3)
240.0.0.0/4         # RFC1112: Reserved
255.255.255.255/32  # RFC0919: Limited Broadcast

# From IANA Multicast Address Space Registry
# http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml
# Updated 2013-06-25

224.0.0.0/4         # RFC5771: Multicast/Reserved
</pre></div>

<p>If you are looking to scan only a random portion of the internet, checkout <a href="#ratelimiting">Sampling</a>, instead of using whitelisting and blacklisting.</p>
<p><span class="label label-info">Heads Up!</span> The default ZMap configuration uses the blacklist file at <code>/etc/zmap/blacklist.conf</code>, which contains locally scoped address space and reserved IP ranges. The default configuration can be changed by editing <code>/etc/zmap/zmap.conf</code>.</p>	
							<br/>


							<a name="ratelimiting"></a> 
							<h3>Rate Limiting and Sampling</h3>

                            <p>By default, ZMap will scan at the fastest rate
that your network adaptor supports. In our experiences on commodity hardware,
this is generally around 95-98% of the theoretical speed of gigabit Ethernet,
which may be faster than your upstream provider can handle. ZMap will <b>not</b>
automatically adjust its send-rate based on your upstream provider.  You may
need to manually adjust your send-rate to reduce packet drops and incorrect results.</p>

							<dl class="dl-horizontal params">
								<dt>-r, --rate=pps</dt><dd>Set maximum send rate in packets/sec</dd>
                                <dt>-B, --bandwidth=bps</dt><dd>Set send rate in bits/sec (supports suffixes G, M, and K). This overrides the <code>--rate</code> flag.</dd>
							</dl>

							<p>ZMap also allows random sampling of the IPv4 address space by specifying max-targets and/or max-runtime. Because hosts are scanned in a random permutation generated per scan instantiation, limiting a scan to <emph>n</emph> hosts will perform a random sampling of <emph>n</emph> hosts. Command-line options:</p>
							<dl class="dl-horizontal params">
							  <dt>-n, --max-targets=n</dt><dd>Cap number of targets to probe</dd>
                              <dt>-N, --max-results=n</dt><dd>Cap number of results (exit after receiving this many positive results)</dd>
							  <dt>-t, --max-runtime=s</dt><dd>Cap length of time for sending packets (in seconds)</dd>
                              <dt>-s, --seed=n</dt><dd>Seed used to select address permutation. Specify the same seed in order to scan addresses
                                                    in the same order for different ZMap runs.</dd>
							</dl>
							<p>For example, if you wanted to scan the same one million hosts on the Internet for multiple scans, you could set a predetermined seed and cap the number of scanned hosts similar to the following:</p>
							<div class="indent"><pre><b>zmap -p 443 -s 3 -n 1000000 -o results</b></pre></div>
							<p>In order to determine which one million hosts were going to be scanned, you could run the scan in dry-run mode which will print out the packets that would be sent instead of performing the actual scan.</p>
							<div class="indent"><pre><b>zmap -p 443 -s 3 -n 1000000 --dryrun | grep daddr
	| awk -F'daddr: ' '{print $2}' | sed 's/ |.*//;' </b></pre></div>
							<br/>


							<a name="multiple"></a> 
							<h3>Sending Multiple Packets</h3>
							<p>ZMap supports sending multiple probes to each host. Increasing this number both increases 
                            scan time and hosts reached. However, we find that the increase in scan time (~100% per additional probe)
                            greatly outweighs the increase in hosts reached (~1% per additional probe).</p>
			
							<dl class="dl-horizontal params">
							  <dt>-P, --probes=n</dt><dd>The number of unique probes to send to each IP (default=1)</dd>
							</dl>
							<br/>
				</div>
   </div>
			
	<div class="row-fluid"> 
      	  <div class="span10 white-panel offset1 nontitle">
           <div class="content">
             <a name="applications"></a>
	     <h3>Sample Applications</h3>
	  	<p>ZMap is designed for initiating contact with a large number of hosts and finding ones
                          that respond positively. However, we realize that many users will want to perform follow-up processing, such as performing an application level handshake. For example, users who perform a TCP SYN scan on port 80 might want to perform a simple GET request and users who scan port 443 may be interested in completing a TLS handshake.</p>

                         <a name="banner-grab"></a>
                         <h4>Banner Grab</h4>

                         <p>We have included a sample application, banner-grab, with ZMap that enables users
                         to receive messages from listening TCP servers. Banner-grab connects to the provided servers,
                         optionally sends a message, and prints out the first message received from the server. This tool
                         can be used to fetch banners such as HTTP server responses to specific commands, telnet login
                         prompts, or SSH server strings.</p>

                         <p>This example finds 1000 servers listening on port 80, and sends a simple GET request to each,
                         storing their base-64 encoded responses in http-banners.out</p>
                         <div class="indent"><pre><b>$ zmap -p 80 -N 1000 -B 10M -o - | ./banner-grab-tcp -p 80 -c 500 -d ./http-req &gt; out</b></pre></div>
                         <p>For more details on using <code>banner-grab</code>, see the README file in <code>examples/banner-grab</code>.</p>

                         <p><span class="label label-info">Heads Up!</span>
                         ZMap and banner-grab can have significant performance and accuracy impact on
                         one another if run simultaneously (as in the example). Make sure not to let
                         ZMap saturate banner-grab-tcp's concurrent connections, otherwise banner-grab
                         will fall behind reading stdin, causing ZMap to block on writing stdout. We 
                         recommend using a slower scanning rate with ZMap, and increasing the concurrency
                         of banner-grab-tcp to no more than 3000 (Note that &gt; 1000 concurrent connections
                         requires you to use <code>ulimit -SHn 100000</code> and <code>ulimit -HHn 100000</code>
                         to increase the maximum file descriptors per process). These parameters will of course
                         be dependent on your server performance, and hit-rate; we encourage developers to experiment
                         with small samples before running a large scan.</p>

                         <a name="forge-socket"></a>
                         <h4>Forge Socket</h4>

						<p>We have also included a form of banner-grab, called forge-socket, that reuses the SYN-ACK
						sent from the server for the connection that ultimately fetches the banner. In <code>banner-grab-tcp</code>,
						ZMap sends a SYN to each server, and listening servers respond with a SYN+ACK. The ZMap host's kernel receives
						this, and sends a RST, as no active connection is associated with that packet. The banner-grab program must
						then create a new TCP connection to the same server to fetch data from it.</p>

						<p>In forge-socket, we utilize a kernel module by the same name, that allows us to create a connection
						with arbitrary TCP parameters. This enables us to suppress the kernel's RST packet, and instead
						create a socket that will reuse the SYN+ACK's parameters, and send and receive data through this socket
						as we would any normally connected socket.</p>

						<p>To use forge-socket, you will need the forge-socket kernel module, available from
						<a href="https://github.com/ewust/forge_socket/">github</a>. You should <code>git clone git@github.com:ewust/forge_socket.git</code>
						in the ZMap root source directory, and then <code>cd</code> into the forge_socket directory, and run <code>make</code>.
						Install the kernel module with <code>insmod forge_socket.ko</code> as root.</p>

						<p>You must also tell the kernel not to send RST packets. An easy way to disable RST packets system wide is
						to use <b>iptables</b>. <code>iptables -A OUTPUT -p tcp -m tcp --tcp-flgas RST,RST RST,RST -j DROP</code> as root will
						do this, though you may also add an optional <code>--dport X</code> to limit this to the port (X) you are scanning.
						To remove this after your scan completes, you can run <code>iptables -D OUTPUT -p tcp -m tcp --tcp-flags RST,RST RST,RST -j DROP</code> 
						as root. </p>
		
						<p>Now you should be able to build the forge-socket ZMap example program. To run it, you must use the <b>extended_file</b>
						ZMap <a href="#outputmodule">output module</a>:</p>
	
                         <div class="indent"><pre>
<b>$ zmap -p 80 -N 1000 -B 10M -O extended_file -o - | \
    ./forge-socket -c 500 -d ./http-req &gt; ./http-banners.out</b></pre></div>

						<p>See the README in <code>examples/forge-socket</code> for more details.</p>
             
					</div>
				</div>
				
								<div class="row-fluid"> 
        					<div class="span10 white-panel offset1 nontitle">
        						<div class="content">
                                 <a name="extending"></a>
        						  <h3>Writing Probe and Output Modules</h3>
        		<p>ZMap can be extended to support different types of scanning through <strong>probe modules</strong> and additional types of results output through <strong>output modules</strong>. Registered probe and output modules can be listed through the command-line interface:</p>
        							<dl class="dl-horizontal params">
        								<dt>--list-probe-modules</dt><dd>Lists installed probe modules</dd>
        								<dt>--list-output-modules</dt><dd>Lists installed output modules</dd>
        							</dl><br/>

                     <a name="outputmodule"></a>
                      <h4>Output Modules</h4>
        							<p>ZMap output and post-processing can be extended by implementing and registering <strong>output modules</strong> with the scanner. Output modules receive a callback for every received response packet. While the default provided modules provide simple output, these modules are also capable of performing additional post-processing (e.g. tracking duplicates or outputting numbers in terms of AS instead of IP address)</p><br/>

        <p>Output modules are created by defining a new output_module struct and registering it in <a href="https://github.com/zmap/zmap/blob/v1.0.0/src/output_modules/output_modules.c">output_modules.c</a>:</p>

        <div class="indent"><pre>
typedef struct output_module {
    const char          *name;           <em>// how is output module referenced in the CLI</em>
    unsigned            update_interval; <em>// how often is update called in seconds</em>
	
    output_init_cb      init;            <em>// called at scanner initialization</em>
    output_update_cb    start;           <em>// called at the beginning of scanner</em>
    output_update_cb    update;          <em>// called every update_interval seconds</em>
    output_update_cb    close;           <em>// called at scanner termination</em>
	
    output_packet_cb    process_ip;      <em>// called when a response is received</em>

    const char          *helptext;       <em>// Printed when --list-output-modules is called</em>
  
} output_module_t;</pre></div>

        <p>Output modules must have a name, which is how they are referenced on the command-line and generally implement <code>success_ip</code> and oftentimes <code>other_ip</code> callback. The process_ip callback is called for every response packet that is received and passed through the output filter by the current <strong>probe module</strong>. The response may or may not be considered a success (e.g. it could be a TCP RST). These callbacks must define functions that match the <code>output_packet_cb</code> definition:</p>

        <div class="indent"><pre>
int (*output_packet_cb) (

    ipaddr_n_t    saddr,         <em>// IP address of scanned host in network-order</em>
    ipaddr_n_t    daddr,         <em>// destination IP address in network-order </em>
    
    const char*   response_type, <em>// send-module classification of packet</em>
    
    int           is_repeat,     <em>// {0: first response from host, 1: subsequent responses}</em>
    int           in_cooldown,   <em>// {0: not in cooldown state, 1: scanner in cooldown state}</em>
    
    const u_char* packet,        <em>// pointer to <code>struct iphdr</code> of IP packet</em>
    size_t        packet_len     <em>// length of packet in bytes</em> 
);
        </pre></div>

        <p>An output module can also register callbacks to be executed at scanner initialization (tasks such as opening an output file), start of the scan (tasks such as documenting blacklisted addresses), during regular intervals during the scan (tasks such as progress updates), and close (tasks such as closing any open file descriptors). These callbacks are provided with complete access to the scan configuration and current state:</p>
        <div class="indent"><pre>int (*output_update_cb)(struct state_conf*, struct state_send*, struct state_recv*);</pre></div>
        <p>which are defined in <a href="https://github.com/zmap/zmap/blob/master/src/output_modules/output_modules.h">output_modules.h</a>. An example is available at <a href="https://github.com/zmap/zmap/blob/master/src/output_modules/module_csv.c">src/output_modules/module_csv.c</a>.</p>
        <br/>

	<a name="probemodule"></a>
        <h4>Probe Modules</h4>

        <p>Packets are constructed using <strong>probe modules</strong> which
        allow abstracted packet creation and response classification. ZMap comes with
        two scan modules by default: <code>tcp_synscan</code> and
        <code>icmp_echoscan</code>. By default, ZMap uses <code>tcp_synscan</code>,
        which sends TCP SYN packets, and classifies responses from each host
        as open (received SYN+ACK) or closed (received RST). ZMap also allows developers
        to write their own probe modules for use with ZMap, using the following API.</p>

        <p>Each type of scan is implemented by developing and registering the necessary callbacks in a <code>send_module_t</code> struct:</p>

        <div class="indent"><pre>
typedef struct probe_module {
    const char               *name;             <em>// how scan is invoked on command-line</em>
    size_t                   packet_length;     <em>// how long is probe packet (must be static size)</em>
    
    const char               *pcap_filter;      <em>// PCAP filter for collecting responses</em>
    size_t                   pcap_snaplen;      <em>// maximum number of bytes for libpcap to capture</em>
    
    uint8_t                  port_args;         <em>// set to 1 if ZMap requires a <code>--target-port</code> be
                                                // specified by the user</em>
    
    probe_global_init_cb     global_initialize; <em>// called once at scanner initialization</em>
    probe_thread_init_cb     thread_initialize; <em>// called once for each thread packet buffer</em>
    probe_make_packet_cb     make_packet;       <em>// called once per host to update packet</em>
    probe_validate_packet_cb validate_packet;   <em>// called once per received packet, 
                                                // return 0 if packet is invalid,
                                                // non-zero otherwise.</em>
    
    probe_print_packet_cb    print_packet;      <em>// called per packet if in dry-run mode</em>
    probe_classify_packet_cb process_packet;   <em>// called by receiver to classify response</em>
    probe_close_cb           close;             <em>// called at scanner termination</em>

    fielddef_t               *fields           <em>// Definitions of the fields specific to this module</em>
    int                      numfields         <em>// Number of fields</em>
    
} probe_module_t;
        </pre></div>

        <br/><p>At scanner initialization, <code>global_initialize</code> is
        called once and can be utilized to perform any necessary global configuration
        or initialization. However, <code>global_initialize</code> does not have access
        to the packet buffer which is thread-specific. Instead,
        <code>thread_initialize</code> is called at the initialization of each sender
        thread and is provided with access to the buffer that will be used for
        constructing probe packets along with global source and destination values.
        This callback should be used to construct the host agnostic packet structure
        such that only specific values (e.g. destination host and checksum) need to be
        be updated for each host. For example, the Ethernet header will not change
        between headers (minus checksum which is calculated in hardware by the NIC) and
        therefore can be defined ahead of time in order to reduce overhead at scan
        time.</p>

        <p>The <code>make_packet</code> callback is called for each host that
        is scanned to allow the <strong>probe module</strong> to update host specific
        values and is provided with IP address values, an opaque validation string,
		and probe number (shown below). The probe module is responsible for placing
		as much of the verification string into the probe, in such a way that when
		a valid response is returned by a server, the probe module can verify that
		it is present. For example, for a TCP SYN scan, the tcp_synscan probe module
		can use the TCP source port and sequence number to store the validation string.
		Response packets (SYN+ACKs) will contain the expected values in the destination
		port and acknowledgement number.</p>


        <div class="indent"><pre>
int make_packet(
    void        *packetbuf,  <em>// packet buffer</em>
    ipaddr_n_t  src_ip,      <em>// source IP in network-order</em>
    ipaddr_n_t	dst_ip,      <em>// destination IP in network-order</em>
    uint32_t    *validation, </em>// validation string to place in probe</em>
    int         probe_num    </em>// if sending multiple probes per host,
                             // this will be which probe number for this
                             // host we are currently sending</em>
);</pre></div><br/>

        <p>Scan modules must also define <code>pcap_filter</code>, <code>validate_packet</code>, and <code>process_packet</code>. Only packets that match the PCAP filter will be considered by the scanner. For example, in the case of a TCP SYN scan, we only want to investigate TCP SYN/ACK or TCP RST packets and would utilize a filter similar to <code>tcp && tcp[13] & 4 != 0 || tcp[13] == 18</code>. The <code>validate_packet</code> function will be called for every packet that fulfills this PCAP filter. If the validation returns non-zero, the <code>process_packet</code> function will be called, and will populate a fieldset using fields defined in <code>fields</code> with data from the packet. For example, the following code processes a packet for the TCP synscan probe module.</p>



        <div class="indent"><pre>
void synscan_process_packet(const u_char *packet, uint32_t len, fieldset_t *fs)
{
    struct iphdr *ip_hdr = (struct iphdr *)&packet[sizeof(struct ethhdr)];
    struct tcphdr *tcp = (struct tcphdr*)((char *)ip_hdr 
            + (sizeof(struct iphdr)));

    fs_add_uint64(fs, "sport", (uint64_t) ntohs(tcp->source)); 
    fs_add_uint64(fs, "dport", (uint64_t) ntohs(tcp->dest));
    fs_add_uint64(fs, "seqnum", (uint64_t) ntohl(tcp->seq));
    fs_add_uint64(fs, "acknum", (uint64_t) ntohl(tcp->ack_seq));
    fs_add_uint64(fs, "window", (uint64_t) ntohs(tcp->window));

    if (tcp->rst) { // RST packet
        fs_add_string(fs, "classification", (char*) "rst", 0);
        fs_add_uint64(fs, "success", 0);
    } else { // SYNACK packet
        fs_add_string(fs, "classification", (char*) "synack", 0);
        fs_add_uint64(fs, "success", 1);
    }
}
</pre></div><br/>

        					</div>
        				</div>

				</div>  

			</div>
			</div>
			</div>
		</div>
	</body>
</html>
